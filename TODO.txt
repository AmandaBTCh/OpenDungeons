--------------- BUGS: ---------------
+  When the terminal command "load" is executed if the loaded level is from a
+  different version of OpenDungeons than the current game the game will print
+  an error message to the terminal and quit, this should be handled more
+  gracefully.
+
*  fix keyboard repeat issue (when the game crashes keyboard repeat is disabled
*  but the OS still thinks it's on, turning it off and then back on again
*  restores the functionality).  This seems to be a bug in OIS so there might
*  not be anything we can do about it.

*  Fix crash on loading a new map from the server, I think it has to do with
*  getting peices of messages in a single packet.  This assumption may or may
*  not be true, it may be that the RenderQueue is somehow processing the
*  addDestination message before the createMesh message.  This can be fixed by
*  adding a mutex style semaphore on the critical sections the
*  ClientSocketProcessor, ClientNotificationProcessor, etc.

*  The GameMap::cutCorners() function sometimes causes creatures to walk
*  through walls, this could be a problem with the lineOfSight function.
*  Actually I think it has to do with Creature::positionTile(), this is mostly
*  fixed although positionTile() may still need some work.  I think that this
*  is fixed now.

+  The client has code to handle when messages are split across packets, but
+  the server does not.  This needs to be added.
+
+  when the terminal becomes active if a key is held down the keyup message
+  gets caught by the terminal and the key is "stuck" down.
+
*  Client and server need to negiotiate and set a color for the newly connected
*  client.

*  Visual debugging entities for creatures dissappear after a short time.

*  When creatures are in the state CreatureAction::maneuver, they sometimes get
*  "stuck" behind an obstacle since they only locally follow the field
*  gradient.  This can be fixed by making them make use of GameMap::path() to
*  find a good path to the destination and sticking with it far enough to get
*  them to their destination.  I have partially fixed this by making the
*  creatures push a walkToTile action to their actionQueue to force them to
*  walk a ways but they could still get stuck in a "big" local minima.

*  When the game exits, many items are placed into the render queue to be
*  deleted, etc.  However, the game exits before calling
*  ExampleFrameListener::startFrame() one last time.  Some kind of mechanism
*  must be put in place to call frameStarted again to flush the render queue so
*  everything is properly freed up.

*  When the game exits during a match with lots of creatures who can see
*  enemies the game will segfault in the Creature::getReachableCreatures()
*  function because the tile that a given creature is standing on
*  (creatureTile) gets deleted from the game map and thus when the query is
*  done it returns NULL.

*  When running a mulitplayer game the client does not get sent the MapLights
*  or the Goals.

*  When running a multiplayer game if another player in the game picks up/drops
*  creatures you don't see the effects on your own display.

+  When using the << and >> operators the 'endl' thing does a flush of the
+  stream, this is likely unnecessary so the endl should usually be replaced by a "\n".

+  Make commandOutput do += rather that = so we see the output form multiple
+  commands. //TODO - Need to check that this does as expected -??

*  When the "tps" terminal command is given a really small value (0.001) the
*  doTurn routine will go into a sleep call for a very long time, subsequent
*  changes of the tps command should cancel the existing sleep routine and
*  re-call it wil the new computed value.  The "fps" command would likely
*  exhibit the exact same behavior.

+  Creature class descriptions don't need to include the ".mesh" on their
+  meshName in the level file since the game engine could just add this itself
+  like it does for rooms, etc
+

*  Convert string casts to string constructors

*  Make the rest of the threads properly call threadLockForTurn() and
*  threadUnlockForTurn() to prevent race conditions.

+--------------- FEATURE ADDITIONS: ---------------
*  Add a goal type ChatMessage which is automatically met and just chats its
*  arguments in its doSuccessAction().

*  Add a function to encapsulate the semaphore lock/unlock as well as the
*  actual Socket::send() command into a single call in something like
*  sendToServer(), also do the same for server->client communication.

+  When doing the floodfill, instead of taking an argument of tile passability,
+  use the passibility of the tile where the fill started.
+
+  Overload the GameMap::path() command to allow the calculation paths between a
+  pair of creature, a creature and a tile,  etc, do the same for other functions?
+
+  Add a parameter to the GameMap class to store the name of the map that was
+  loaded and make the terminal commands load/save automatically use this name
+  unless another level name is provided.
+
+  When a level is loaded the number of tiles, classes, and creatures loaded is
+  displayed, make this also display the number of MapLights, etc.  Possibly
+  make the save command do the same.
+
+  Add a vector of failedGoals to the Seat class similar to completedGoals.
+
+  Add a vector of sub goals to the Goal class which are added to the queue
+  after the given goal is completed.
+
+  Add a function and a datamember to the Creature class to go into a specified
+  animation state when the walk queue becomes empty.
+
*  Add tile colors to the level file and network protocols.

*  Add a seperate thread to generate a pool of 5000 or so random numbers for
*  use when needed and make the randomDouble, etc. functions consumers on this pool.

*  Begin phasing out snprintf since it is not portable.

*  implement history on the terminal.
*  implement line editing on the terminal.
	Both of these will be fixed by moving to a better terminal, see:
	http://www.ogre3d.org/wiki/index.php/CodeSnippits#Console

*  add a flyTo method to make the camera fly to a particular location (and
*  orientation?).

*  Store creature classes and class descriptions in maps rather than vectors to
*  allow for faster lookups.

*  Add play, pause, and single turn commands to the terminal to aid in AI
*  debugging. 

*  Add a terminal command to set the number of chat messages and the time to
*  display them for (both as one command maybe).

*  Create various levels of quality for each mesh and make a RenderRequest that
*  switches to new meshes when some criteria is met (use something stable like
*  num items onscreen at once to avoid churning between mesh detail levels, or
*  change the meshes one at a time and re-evaluate).  It looks like OGRE has a
*  built in mechanism to do this dynamically.

*  Test limiting the number of render requests that can be handled per frame,
*  initial tests did not seem encouraging so maybe this is a bad idea.

*  Color chat messages with the color of the player who sent them.

*  Make use of std::set instead of std::vector where appropriate.

*  Add a new tile type which automatically grows tiles next to it when a
*  creature gets within a certain distance of it.

 ---------------

*  Fix the issue with Mouse move.

*  find out about separate subtraction and multiply issue in
*  ExampleFrameListener::mouseMoved(const OIS::MouseEvent &arg)

 ---------------

*  make camera center stay focused on the same point and rotate around it
*  rather than rotating the camera around a fixed point.

*  add a disconnect command to stop the running client or server thread.

