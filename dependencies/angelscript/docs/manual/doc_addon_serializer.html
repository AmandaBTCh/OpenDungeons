<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AngelScript: Serializer</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1><a class="anchor" name="doc_addon_serializer">Serializer </a></h1><b>Path:</b> /sdk/add_on/serializer/<p>
The <code>CSerializer</code> implements support for serializing the values of global variables in a module, for example in order to reload a slightly modified version of the script without reinitializing everything. It will resolve primitives and script classes automatically, including references and handles. For application registered types, the application needs to implement callback objects to show how these should be serialized.<p>
The implementation currently has some limitations:<p>
<ul>
<li>It can only serialize to memory, i.e. it is not possible to save the values to a file.</li><li>If the variables changed type when restoring, the serializer cannot restore the value.</li><li>The serializer will attempt to backup all objects, but in some cases an application may not want to backup the actual object, but only a reference to it, e.g. an internal application object referenced by the script. Currently there is no way of telling the serializer to do differently in this case.</li><li>If the module holds references to objects from another module it will probably fail in restoring the values.</li></ul>
<h2><a class="anchor" name="doc_addon_serializer_1">
Public C++ interface</a></h2>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CSerializer
{
<span class="keyword">public</span>:
  CSerializer();
  ~CSerializer();

  <span class="comment">// Add implementation for serializing user types</span>
  <span class="keywordtype">void</span> AddUserType(CUserType *ref, <span class="keyword">const</span> std::string &amp;name);

  <span class="comment">// Store all global variables in the module</span>
  <span class="keywordtype">int</span> Store(<a class="code" href="classas_i_script_module.html" title="The interface to the script modules.">asIScriptModule</a> *mod);

  <span class="comment">// Restore all global variables after reloading script</span>
  <span class="keywordtype">int</span> Restore(<a class="code" href="classas_i_script_module.html" title="The interface to the script modules.">asIScriptModule</a> *mod);
};
</pre></div><h2><a class="anchor" name="doc_addon_serializer_2">
Example usage</a></h2>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>CStringType;
<span class="keyword">struct </span>CArrayType;

<span class="keywordtype">void</span> RecompileModule(<a class="code" href="classas_i_script_engine.html" title="The engine interface.">asIScriptEngine</a> *engine, <a class="code" href="classas_i_script_module.html" title="The interface to the script modules.">asIScriptModule</a> *mod)
{
  <span class="keywordtype">string</span> modName = mod-&gt;<a class="code" href="classas_i_script_module.html#4967db3ed89836ac2f3b529c499d473d" title="Gets the name of the module.">GetName</a>();

  <span class="comment">// Tell the serializer how the user types should be serialized</span>
  <span class="comment">// by adding the implementations of the CUserType interface</span>
  CSerializer backup;
  backup.AddUserType(<span class="keyword">new</span> CStringType(), <span class="stringliteral">"string"</span>);
  backup.AddUserType(<span class="keyword">new</span> CArrayType(), <span class="stringliteral">"array"</span>);

  <span class="comment">// Backup the values of the global variables</span>
  modStore.Store(mod);
  
  <span class="comment">// Application can now recompile the module</span>
  CompileModule(modName);

  <span class="comment">// Restore the values of the global variables in the new module</span>
  mod = engine-&gt;<a class="code" href="classas_i_script_engine.html#9f7cdc52b59034e6e55eb8a56b427aa4" title="Return an interface pointer to the module.">GetModule</a>(modName.c_str(), <a class="code" href="angelscript_8h.html#e4cf50de5273eb8c03c6e91e6e014f0c2feb963eb04c221e251867bc3a93d79d" title="Don&amp;#39;t return any module if it is not found.">asGM_ONLY_IF_EXISTS</a>);
  backup.Restore(mod);
}

<span class="comment">// This serializes the std::string type</span>
<span class="keyword">struct </span>CStringType : <span class="keyword">public</span> CUserType
{
  <span class="keywordtype">void</span> Store(CSerializedValue *val, <span class="keywordtype">void</span> *ptr)
  {
    val-&gt;SetUserData(<span class="keyword">new</span> std::string(*(std::string*)ptr));
  }
  <span class="keywordtype">void</span> Restore(CSerializedValue *val, <span class="keywordtype">void</span> *ptr)
  {
    std::string *buffer = (std::string*)val-&gt;GetUserData();
    *(std::string*)ptr = *buffer;
  }
  <span class="keywordtype">void</span> CleanupUserData(CSerializedValue *val)
  {
    std::string *buffer = (std::string*)val-&gt;GetUserData();
    <span class="keyword">delete</span> buffer;
  }
};

<span class="comment">// This serializes the CScriptArray type</span>
<span class="keyword">struct </span>CArrayType : <span class="keyword">public</span> CUserType
{
  <span class="keywordtype">void</span> Store(CSerializedValue *val, <span class="keywordtype">void</span> *ptr)
  {
    CScriptArray *arr = (CScriptArray*)ptr;

    <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; arr-&gt;GetSize(); i++ )
      val-&gt;m_children.push_back(<span class="keyword">new</span> CSerializedValue(val ,<span class="stringliteral">""</span>, arr-&gt;At(i), arr-&gt;GetElementTypeId()));
  }
  <span class="keywordtype">void</span> Restore(CSerializedValue *val, <span class="keywordtype">void</span> *ptr)
  {
    CScriptArray *arr = (CScriptArray*)ptr;
    arr-&gt;Resize(val-&gt;m_children.size());

    <span class="keywordflow">for</span>( <span class="keywordtype">size_t</span> i = 0; i &lt; val-&gt;m_children.size(); ++i )
      val-&gt;m_children[i]-&gt;Restore(arr-&gt;At(i));
  }
};
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Sun Aug 21 13:13:47 2011 for AngelScript by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
